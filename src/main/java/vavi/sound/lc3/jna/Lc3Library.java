package vavi.sound.lc3.jna;

import java.nio.IntBuffer;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;


/**
 * JNA Wrapper for library <b>lc3</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Lc3Library extends Library {

    String JNA_LIBRARY_NAME = "LC3plus";
    NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(Lc3Library.JNA_LIBRARY_NAME);
    Lc3Library INSTANCE = Native.load(Lc3Library.JNA_LIBRARY_NAME, Lc3Library.class);

    /**
     * <i>native declaration : lc3.h</i><br>
     * enum values
     */
    interface LC3PLUS_PlcMode {

        /**
         * < Enhanced concealment method<br>
         * <i>native declaration : lc3.h:60</i>
         */
        int LC3PLUS_PLC_ADVANCED = 1;
    }

    /**
     * <i>native declaration : lc3.h</i><br>
     * enum values
     */
    interface LC3PLUS_EpMode {

        /**
         * < Error protection is disabled<br>
         * <i>native declaration : lc3.h:67</i>
         */
        int LC3PLUS_EP_OFF = 0;
        /**
         * < Error protection with 0 bit correction<br>
         * <i>native declaration : lc3.h:68</i>
         */
        int LC3PLUS_EP_ZERO = 1;
        /**
         * < Error protection correcting one symbol per codeword<br>
         * <i>native declaration : lc3.h:69</i>
         */
        int LC3PLUS_EP_LOW = 2;
        /**
         * < Error protection correcting two symbols per codeword<br>
         * <i>native declaration : lc3.h:70</i>
         */
        int LC3PLUS_EP_MEDIUM = 3;
        /**
         * < Error protection correcting three symbols per codeword<br>
         * <i>native declaration : lc3.h:71</i>
         */
        int LC3PLUS_EP_HIGH = 4;
    }

    /**
     * <i>native declaration : lc3.h</i><br>
     * enum values
     */
    interface LC3PLUS_EpModeRequest {

        /**
         * < Request no error correction. High confidence if returned by decoder.<br>
         * <i>native declaration : lc3.h:78</i>
         */
        int LC3PLUS_EPMR_ZERO = 0;
        /**
         * < Request low error correction. High confidence if returned by decoder.<br>
         * <i>native declaration : lc3.h:79</i>
         */
        int LC3PLUS_EPMR_LOW = 1;
        /**
         * < Request medium error correction. High confidence if returned by decoder.<br>
         * <i>native declaration : lc3.h:80</i>
         */
        int LC3PLUS_EPMR_MEDIUM = 2;
        /**
         * < Request high error correction. High confidence if returned by decoder.<br>
         * <i>native declaration : lc3.h:81</i>
         */
        int LC3PLUS_EPMR_HIGH = 3;
        /**
         * < No error correction requested, medium confidence.<br>
         * <i>native declaration : lc3.h:82</i>
         */
        int LC3PLUS_EPMR_ZERO_MC = 4;
        /**
         * < Low error correction requested, medium confidence.<br>
         * <i>native declaration : lc3.h:83</i>
         */
        int LC3PLUS_EPMR_LOW_MC = 5;
        /**
         * < Medium error correction requested, medium confidence.<br>
         * <i>native declaration : lc3.h:84</i>
         */
        int LC3PLUS_EPMR_MEDIUM_MC = 6;
        /**
         * < High error correction requested, medium confidence.<br>
         * <i>native declaration : lc3.h:85</i>
         */
        int LC3PLUS_EPMR_HIGH_MC = 7;
        /**
         * < No error correction requested, unvalidated.<br>
         * <i>native declaration : lc3.h:86</i>
         */
        int LC3PLUS_EPMR_ZERO_NC = 8;
        /**
         * < Low error correction requested, unvalidated.<br>
         * <i>native declaration : lc3.h:87</i>
         */
        int LC3PLUS_EPMR_LOW_NC = 9;
        /**
         * < Medium error correction requested, unvalidated.<br>
         * <i>native declaration : lc3.h:88</i>
         */
        int LC3PLUS_EPMR_MEDIUM_NC = 10;
        /**
         * < High error correction requested, unvalidated.<br>
         * <i>native declaration : lc3.h:89</i>
         */
        int LC3PLUS_EPMR_HIGH_NC = 11;
    }

    /**
     * <i>native declaration : lc3.h</i><br>
     * enum values
     */
    interface LC3PLUS_Error {

        /**
         * < No error occurred<br>
         * <i>native declaration : lc3.h:95</i>
         */
        int LC3PLUS_OK = 0;
        /**
         * < Function call failed<br>
         * <i>native declaration : lc3.h:96</i>
         */
        int LC3PLUS_ERROR = 1;
        /**
         * < Frame failed to decode and was concealed<br>
         * <i>native declaration : lc3.h:97</i>
         */
        int LC3PLUS_DECODE_ERROR = 2;
        /**
         * < Pointer argument is null<br>
         * <i>native declaration : lc3.h:98</i>
         */
        int LC3PLUS_NULL_ERROR = 3;
        /**
         * < Invalid samplerate value<br>
         * <i>native declaration : lc3.h:99</i>
         */
        int LC3PLUS_SAMPLERATE_ERROR = 4;
        /**
         * < Invalid channels value<br>
         * <i>native declaration : lc3.h:100</i>
         */
        int LC3PLUS_CHANNELS_ERROR = 5;
        /**
         * < Invalid bitrate value<br>
         * <i>native declaration : lc3.h:101</i>
         */
        int LC3PLUS_BITRATE_ERROR = 6;
        /**
         * < Invalid num_bytes value<br>
         * <i>native declaration : lc3.h:102</i>
         */
        int LC3PLUS_NUMBYTES_ERROR = 7;
        /**
         * < Invalid plc_method value<br>
         * <i>native declaration : lc3.h:103</i>
         */
        int LC3PLUS_PLCMODE_ERROR = 8;
        /**
         * < Invalid epmode value<br>
         * <i>native declaration : lc3.h:104</i>
         */
        int LC3PLUS_EPMODE_ERROR = 9;
        /**
         * < Invalid frame_ms value<br>
         * <i>native declaration : lc3.h:105</i>
         */
        int LC3PLUS_FRAMEMS_ERROR = 10;
        /**
         * < Unaligned pointer<br>
         * <i>native declaration : lc3.h:106</i>
         */
        int LC3PLUS_ALIGN_ERROR = 11;
        /**
         * < Invalid epmr value<br>
         * <i>native declaration : lc3.h:107</i>
         */
        int LC3PLUS_EPMR_ERROR = 12;
        /**
         * < Invalid usage of hrmode, sampling rate and frame size<br>
         * <i>native declaration : lc3.h:108</i>
         */
        int LC3PLUS_HRMODE_ERROR = 13;
        /**
         * < Function called before bitrate has been set<br>
         * <i>native declaration : lc3.h:109</i>
         */
        int LC3PLUS_BITRATE_UNSET_ERROR = 14;
        /**
         * < Function called after bitrate has been set<br>
         * <i>native declaration : lc3.h:110</i>
         */
        int LC3PLUS_BITRATE_SET_ERROR = 15;
        /**
         * < Invalid external bad frame index<br>
         * <i>native declaration : lc3.h:111</i>
         */
        int LC3PLUS_BFI_EXT_ERROR = 16;
        /** <i>native declaration : lc3.h:114</i> */
        int LC3PLUS_WARNING = 17;
        /**
         * < Invalid bandwidth cutoff frequency<br>
         * <i>native declaration : lc3.h:115</i>
         */
        int LC3PLUS_BW_WARNING = 18;
    }

    /** <i>native declaration : lc3.h</i> */
    int LC3PLUS_VERSION = ((1) << 16) | ((6) << 8) | (3);
    /** <i>native declaration : lc3.h</i> */
    int LC3PLUS_MAX_CHANNELS = 2;
    /** <i>native declaration : lc3.h</i> */
    int LC3PLUS_MAX_SAMPLES = 960;
    /** <i>native declaration : lc3.h</i> */
    int LC3PLUS_MAX_BYTES = (625 * LC3PLUS_MAX_CHANNELS);
    /** <i>native declaration : lc3.h</i> */
    int LC3PLUS_ENC_MAX_SIZE = 12628;
    /** <i>native declaration : lc3.h</i> */
    int LC3PLUS_DEC_MAX_SIZE = 42488;
    /** <i>native declaration : lc3.h</i> */
    int LC3PLUS_ENC_MAX_SCRATCH_SIZE = 45624;
    /** <i>native declaration : lc3.h</i> */
    int LC3PLUS_DEC_MAX_SCRATCH_SIZE = 59768;

    /**
     * Return library version number. It should match LC3PLUS_VERSION.<br>
     * Original signature : <code>int lc3plus_version()</code><br>
     * <i>native declaration : lc3.h:126</i>
     */
    int lc3plus_version();

    /**
     * Tests if the library supports number of channels.<br>
     * @param channels [in]    Number of channels.<br>
     * @return                 1 for true, 0 for false.<br>
     * Original signature : <code>int lc3plus_channels_supported(int)</code><br>
     * <i>native declaration : lc3.h:133</i>
     */
    int lc3plus_channels_supported(int channels);

    /**
     * Tests if the library supports a sampling rate.<br>
     * @param samplerate [in]  Sampling rate<br>
     * @return                 1 for true, 0 for false<br>
     * Original signature : <code>int lc3plus_samplerate_supported(int)</code><br>
     * <i>native declaration : lc3.h:140</i>
     */
    int lc3plus_samplerate_supported(int samplerate);

    /**
     * Initialize LC3 encoder.<br>
     * This function is used to fill a user-allocated encoder struct. This is typically<br>
     * called once for a samplerate / channel configuration. After init and before encoding<br>
     * the first frame you must call lc3_enc_set_bitrate().<br>
     * @param encoder [out]     Pointer to allocated encoder memory. It must have a size provided<br>
     * by lc3_enc_get_size() for matching samplerate / channels<br>
     * configuration or LC3_ENC_MAX_SIZE.<br>
     * @param channels [in]    Number of channels.<br>
     * @param samplerate [in]  Input sampling rate. Allowed sampling rates are:<br>
     * 8000, 16000, 24000, 32000, 44100, 48000<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_init(LC3PLUS_Enc*, int, int)</code><br>
     * <i>native declaration : lc3.h:161</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_init(com.sun.jna.ptr.PointerByReference, int, int)} instead
     */
    @Deprecated
    int lc3plus_enc_init(Pointer encoder, int samplerate, int channels, int hrmode);

    /**
     * Initialize LC3 encoder.<br>
     * This function is used to fill a user-allocated encoder struct. This is typically<br>
     * called once for a samplerate / channel configuration. After init and before encoding<br>
     * the first frame you must call lc3_enc_set_bitrate().<br>
     * @param encoder [out]     Pointer to allocated encoder memory. It must have a size provided<br>
     * by lc3_enc_get_size() for matching samplerate / channels<br>
     * configuration or LC3_ENC_MAX_SIZE.<br>
     * @param channels [in]    Number of channels.<br>
     * @param samplerate [in]  Input sampling rate. Allowed sampling rates are:<br>
     * 8000, 16000, 24000, 32000, 44100, 48000<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_init(LC3PLUS_Enc*, int, int)</code><br>
     * <i>native declaration : lc3.h:161</i>
     */
    int lc3plus_enc_init(PointerByReference encoder, int samplerate, int channels, int hrmode);

    /**
     * Encode LC3 frame with 16 bit input.<br>
     * Each call consumes a fixed number of samples. The number of input samples<br>
     * can be obtained from lc3_enc_get_input_samples().<br>
     * @param encoder [in]         Encoder handle initialized by lc3_enc_init().<br>
     * @param input_samples [in]   Input samples. The left channel is stored in input_samples[0],<br>
     * the right channel in input_samples[1]. The input is not changed<br>
     * by the encoder.<br>
     * @param output_bytes [out]    Output buffer. It must have a at least lc3_enc_get_num_bytes()<br>
     * or at most LC3PLUS_MAX_BYTES.<br>
     * @param num_bytes [out]       Number of bytes written to output_bytes.<br>
     * @param      scratch         A pointer to an allocated work buffer of at least<br>
     * lc3_enc_get_scratch_size() or at most LC3_ENC_SCRATCH_SIZE bytes.<br>
     * The buffer does not have to persist, so it can be used for other<br>
     * purposes in between calls.<br>
     * @return                     LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc16(LC3PLUS_Enc*, int16_t**, void*, int*, void*)</code><br>
     * <i>native declaration : lc3.h:186</i><br>
     *
     * @deprecated use the safer methods {@link #lc3plus_enc16(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, java.nio.IntBuffer, com.sun.jna.Pointer)} and {@link #lc3plus_enc16(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    int lc3plus_enc16(Pointer encoder, PointerByReference input_samples, Pointer output_bytes, IntByReference num_bytes, Pointer scratch);

    /**
     * Encode LC3 frame with 16 bit input.<br>
     * Each call consumes a fixed number of samples. The number of input samples<br>
     * can be obtained from lc3_enc_get_input_samples().<br>
     * @param encoder [in]         Encoder handle initialized by lc3_enc_init().<br>
     * @param input_samples [in]   Input samples. The left channel is stored in input_samples[0],<br>
     * the right channel in input_samples[1]. The input is not changed<br>
     * by the encoder.<br>
     * @param output_bytes [out]    Output buffer. It must have a at least lc3_enc_get_num_bytes()<br>
     * or at most LC3PLUS_MAX_BYTES.<br>
     * @param num_bytes [out]       Number of bytes written to output_bytes.<br>
     * @param      scratch         A pointer to an allocated work buffer of at least<br>
     * lc3_enc_get_scratch_size() or at most LC3_ENC_SCRATCH_SIZE bytes.<br>
     * The buffer does not have to persist, so it can be used for other<br>
     * purposes in between calls.<br>
     * @return                     LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc16(LC3PLUS_Enc*, int16_t**, void*, int*, void*)</code><br>
     * <i>native declaration : lc3.h:186</i>
     */
    int lc3plus_enc16(PointerByReference encoder, PointerByReference input_samples, Pointer output_bytes, IntBuffer num_bytes, Pointer scratch);

    /**
     * Encode LC3 frame with 16 bit input.<br>
     * Each call consumes a fixed number of samples. The number of input samples<br>
     * can be obtained from lc3_enc_get_input_samples().<br>
     * @param encoder [in]         Encoder handle initialized by lc3_enc_init().<br>
     * @param input_samples [in]   Input samples. The left channel is stored in input_samples[0],<br>
     * the right channel in input_samples[1]. The input is not changed<br>
     * by the encoder.<br>
     * @param output_bytes [out]    Output buffer. It must have a at least lc3_enc_get_num_bytes()<br>
     * or at most LC3PLUS_MAX_BYTES.<br>
     * @param num_bytes [out]       Number of bytes written to output_bytes.<br>
     * @param      scratch         A pointer to an allocated work buffer of at least<br>
     * lc3_enc_get_scratch_size() or at most LC3_ENC_SCRATCH_SIZE bytes.<br>
     * The buffer does not have to persist, so it can be used for other<br>
     * purposes in between calls.<br>
     * @return                     LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc16(LC3PLUS_Enc*, int16_t**, void*, int*, void*)</code><br>
     * <i>native declaration : lc3.h:186</i>
     */
    int lc3plus_enc16(PointerByReference encoder, PointerByReference input_samples, Pointer output_bytes, IntByReference num_bytes, Pointer scratch);

    /**
     * Encode LC3 frame with 24 bit input.<br>
     * The input samples are expected to be 24-bit values, sign-extended to 32-bit.<br>
     * See lc3_enc16() for parameter documentation.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc24(LC3PLUS_Enc*, int32_t**, void*, int*, void*)</code><br>
     * <i>native declaration : lc3.h:193</i><br>
     *
     * @deprecated use the safer methods {@link #lc3plus_enc24(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, java.nio.IntBuffer, com.sun.jna.Pointer)} and {@link #lc3plus_enc24(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer)} instead
     */
    @Deprecated
    int lc3plus_enc24(Pointer encoder, PointerByReference input_samples, Pointer output_bytes, IntByReference num_bytes, Pointer scratch);

    /**
     * Encode LC3 frame with 24 bit input.<br>
     * The input samples are expected to be 24-bit values, sign-extended to 32-bit.<br>
     * See lc3_enc16() for parameter documentation.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc24(LC3PLUS_Enc*, int32_t**, void*, int*, void*)</code><br>
     * <i>native declaration : lc3.h:193</i>
     */
    int lc3plus_enc24(PointerByReference encoder, PointerByReference input_samples, Pointer output_bytes, IntBuffer num_bytes, Pointer scratch);

    /**
     * Encode LC3 frame with 24 bit input.<br>
     * The input samples are expected to be 24-bit values, sign-extended to 32-bit.<br>
     * See lc3_enc16() for parameter documentation.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc24(LC3PLUS_Enc*, int32_t**, void*, int*, void*)</code><br>
     * <i>native declaration : lc3.h:193</i>
     */
    int lc3plus_enc24(PointerByReference encoder, PointerByReference input_samples, Pointer output_bytes, IntByReference num_bytes, Pointer scratch);

    /**
     * Get the size of the LC3 encoder struct for a samplerate / channel configuration.<br>
     * If memory is not restricted LC3_ENC_MAX_SIZE can be used for all configurations.<br>
     * @param samplerate [in]  Sampling rate.<br>
     * @param channels [in]    Number of channels.<br>
     * @return                 Size in bytes or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_size(int, int)</code><br>
     * <i>native declaration : lc3.h:202</i>
     */
    int lc3plus_enc_get_size(int samplerate, int channels);

    /**
     * Get the size of the scratch buffer required by lc3_enc16() or lc3_enc24() for the current<br>
     * encoder configuration. If memory is not restricted, LC3_ENC_MAX_SCRATCH_SIZE can be used for<br>
     * all configurations.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Size in bytes or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_scratch_size(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:211</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_get_scratch_size(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_enc_get_scratch_size(Pointer encoder);

    /**
     * Get the size of the scratch buffer required by lc3_enc16() or lc3_enc24() for the current<br>
     * encoder configuration. If memory is not restricted, LC3_ENC_MAX_SCRATCH_SIZE can be used for<br>
     * all configurations.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Size in bytes or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_scratch_size(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:211</i>
     */
    int lc3plus_enc_get_scratch_size(PointerByReference encoder);

    /**
     * Get number of samples per channel expected by lc3_enc16() or lc3_enc24().<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Number of samples or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_input_samples(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:218</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_get_input_samples(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_enc_get_input_samples(Pointer encoder);

    /**
     * Get number of samples per channel expected by lc3_enc16() or lc3_enc24().<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Number of samples or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_input_samples(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:218</i>
     */
    int lc3plus_enc_get_input_samples(PointerByReference encoder);

    /**
     * Get real internal bitrate of the encoder. It might differ from the requested bitrate due<br>
     * to error protection or 44.1 kHz input.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Bitrate in bits per second or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_real_bitrate(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:226</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_get_real_bitrate(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_enc_get_real_bitrate(Pointer encoder);

    /**
     * Get real internal bitrate of the encoder. It might differ from the requested bitrate due<br>
     * to error protection or 44.1 kHz input.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Bitrate in bits per second or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_real_bitrate(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:226</i>
     */
    int lc3plus_enc_get_real_bitrate(PointerByReference encoder);

    /**
     * Get the maximum number of bytes produced by lc3_enc16() or lc3_enc24() for the current<br>
     * bitrate. It should be equal to the num_bytes output of lc3_enc16().<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Size in bytes or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_num_bytes(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:234</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_get_num_bytes(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_enc_get_num_bytes(Pointer encoder);

    /**
     * Get the maximum number of bytes produced by lc3_enc16() or lc3_enc24() for the current<br>
     * bitrate. It should be equal to the num_bytes output of lc3_enc16().<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Size in bytes or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_num_bytes(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:234</i>
     */
    int lc3plus_enc_get_num_bytes(PointerByReference encoder);

    /**
     * Set encoder bitrate for all channels.<br>
     * This function must be called at least once before encoding the first frame, but<br>
     * after other configuration functions such as lc3_enc_set_frame_dms().<br>
     * Recommended bitrates for input sampling rates with 10 ms framing:<br>
     * kHz     | kbps<br>
     * --------|-----<br>
     * 8       | 24<br>
     * 16      | 32<br>
     * 24      | 48<br>
     * 32      | 64<br>
     * 44.1/48 | 80(voice) 128(music)<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param bitrate [in]     Bitrate in bits per second.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_bitrate(LC3PLUS_Enc*, int)</code><br>
     * <i>native declaration : lc3.h:253</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_set_bitrate(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    int lc3plus_enc_set_bitrate(Pointer encoder, int bitrate);

    /**
     * Set encoder bitrate for all channels.<br>
     * This function must be called at least once before encoding the first frame, but<br>
     * after other configuration functions such as lc3_enc_set_frame_dms().<br>
     * Recommended bitrates for input sampling rates with 10 ms framing:<br>
     * kHz     | kbps<br>
     * --------|-----<br>
     * 8       | 24<br>
     * 16      | 32<br>
     * 24      | 48<br>
     * 32      | 64<br>
     * 44.1/48 | 80(voice) 128(music)<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param bitrate [in]     Bitrate in bits per second.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_bitrate(LC3PLUS_Enc*, int)</code><br>
     * <i>native declaration : lc3.h:253</i>
     */
    int lc3plus_enc_set_bitrate(PointerByReference encoder, int bitrate);

    /**
     * Set encoder Low-frequency effect moded. deactivates LTPF, TNS, NF<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param lfe [in]         LFE mode flag<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_lfe(LC3PLUS_Enc*, int)</code><br>
     * <i>native declaration : lc3.h:261</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_set_lfe(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    int lc3plus_enc_set_lfe(Pointer encoder, int lfe);

    /**
     * Set encoder Low-frequency effect moded. deactivates LTPF, TNS, NF<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param lfe [in]         LFE mode flag<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_lfe(LC3PLUS_Enc*, int)</code><br>
     * <i>native declaration : lc3.h:261</i>
     */
    int lc3plus_enc_set_lfe(PointerByReference encoder, int lfe);

    /**
     * Get the encoder delay in number of samples.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Encoder in samples or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_delay(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:268</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_get_delay(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_enc_get_delay(Pointer encoder);

    /**
     * Get the encoder delay in number of samples.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @return                 Encoder in samples or 0 on error.<br>
     * Original signature : <code>int lc3plus_enc_get_delay(const LC3PLUS_Enc*)</code><br>
     * <i>native declaration : lc3.h:268</i>
     */
    int lc3plus_enc_get_delay(PointerByReference encoder);

    /**
     * Set the frame length for LC3 encoder in deci milliseconds.<br>
     * Not all lengths may be enabled, in that case LC3PLUS_FRAMEMS_ERROR is returned.<br>
     * This function must be called before lc3_enc_set_bitrate(). The decoder must be<br>
     * configured with LC3PLUS_Dec_set_frame_dms() with the same value.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param frame_ms [in]    Frame length in ms.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_frame_dms(LC3PLUS_Enc*, int)</code><br>
     * <i>native declaration : lc3.h:279</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_set_frame_dms(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    int lc3plus_enc_set_frame_dms(Pointer encoder, int frame_ms);

    /**
     * Set the frame length for LC3 encoder in deci milliseconds.<br>
     * Not all lengths may be enabled, in that case LC3PLUS_FRAMEMS_ERROR is returned.<br>
     * This function must be called before lc3_enc_set_bitrate(). The decoder must be<br>
     * configured with LC3PLUS_Dec_set_frame_dms() with the same value.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param frame_ms [in]    Frame length in ms.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_frame_dms(LC3PLUS_Enc*, int)</code><br>
     * <i>native declaration : lc3.h:279</i>
     */
    int lc3plus_enc_set_frame_dms(PointerByReference encoder, int frame_ms);

    /**
     * Set error protection mode. The default is LC3PLUS_EP_OFF. It is possible to switch between<br>
     * different modees during encoding. Dynamic switching is only allowed between LC3_EP_ZERO,<br>
     * LC3_EP_LOW, LC3_EP_MEDIUM, and LC3PLUS_EP_HIGH. The the decoder must be notified with<br>
     * LC3PLUS_Dec_set_ep_enabled() to expect protected data if epmode is other than LC3PLUS_EP_OFF.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param epmode [in]      Error protection mode.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_ep_mode(LC3PLUS_Enc*, LC3PLUS_EpMode)</code><br>
     * <i>native declaration : lc3.h:290</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_set_ep_mode(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    int lc3plus_enc_set_ep_mode(Pointer encoder, int epmode);

    /**
     * Set error protection mode. The default is LC3PLUS_EP_OFF. It is possible to switch between<br>
     * different modees during encoding. Dynamic switching is only allowed between LC3_EP_ZERO,<br>
     * LC3_EP_LOW, LC3_EP_MEDIUM, and LC3PLUS_EP_HIGH. The the decoder must be notified with<br>
     * LC3PLUS_Dec_set_ep_enabled() to expect protected data if epmode is other than LC3PLUS_EP_OFF.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param epmode [in]      Error protection mode.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_ep_mode(LC3PLUS_Enc*, LC3PLUS_EpMode)</code><br>
     * <i>native declaration : lc3.h:290</i>
     */
    int lc3plus_enc_set_ep_mode(PointerByReference encoder, int epmode);

    /**
     * Sets error protection mode request transmitted in each channel encoded frame.<br>
     * The channel coder includes an error protection mode request (EPMR) in every frame.<br>
     * The EPMR takes value 0, 1, 2, and 3 which request ep modes 1, 2, 3, and 4 from the<br>
     * decoding device. The EPMR can be retrieved from the channel decoder via the interface<br>
     * routine LC3PLUS_Dec_get_ep_mode_request().<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param epmr [in]        Error Protection Mode Request<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_ep_mode_request(LC3PLUS_Enc*, LC3PLUS_EpModeRequest)</code><br>
     * <i>native declaration : lc3.h:302</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_set_ep_mode_request(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    int lc3plus_enc_set_ep_mode_request(Pointer encoder, int epmr);

    /**
     * Sets error protection mode request transmitted in each channel encoded frame.<br>
     * The channel coder includes an error protection mode request (EPMR) in every frame.<br>
     * The EPMR takes value 0, 1, 2, and 3 which request ep modes 1, 2, 3, and 4 from the<br>
     * decoding device. The EPMR can be retrieved from the channel decoder via the interface<br>
     * routine LC3PLUS_Dec_get_ep_mode_request().<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param epmr [in]        Error Protection Mode Request<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_ep_mode_request(LC3PLUS_Enc*, LC3PLUS_EpModeRequest)</code><br>
     * <i>native declaration : lc3.h:302</i>
     */
    int lc3plus_enc_set_ep_mode_request(PointerByReference encoder, int epmr);

    /**
     * Set encoder bandwidth to a different value. All frequency bins above the cutoff<br>
     * frequency are cut off. Allowed frequencies are: 4 kHz, 8 kHz, 12 kHz, 16 kHz and 24 kHz.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param bandwidth [in]   Cutoff Frequency in Hz<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_bandwidth(LC3PLUS_Enc*, int)</code><br>
     * <i>native declaration : lc3.h:311</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_enc_set_bandwidth(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    int lc3plus_enc_set_bandwidth(Pointer encoder, int bandwidth);

    /**
     * Set encoder bandwidth to a different value. All frequency bins above the cutoff<br>
     * frequency are cut off. Allowed frequencies are: 4 kHz, 8 kHz, 12 kHz, 16 kHz and 24 kHz.<br>
     * @param encoder [in]     Encoder handle.<br>
     * @param bandwidth [in]   Cutoff Frequency in Hz<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_enc_set_bandwidth(LC3PLUS_Enc*, int)</code><br>
     * <i>native declaration : lc3.h:311</i>
     */
    int lc3plus_enc_set_bandwidth(PointerByReference encoder, int bandwidth);

    /**
     * Initialize LC3 decoder.<br>
     * This function is used to fill a user-allocated decoder struct. This is typically<br>
     * called once for a samplerate / channel / plc_mode configuration.<br>
     * The samplerate and channel arguments must have the same values that were used for encoding.<br>
     * LC3 does not provide a signalling scheme, transporting these values is the responsibility<br>
     * of the application.<br>
     * @param decoder [out]         Pointer to decoder memory. It must have as size of least<br>
     * LC3PLUS_Dec_get_size() or at most LC3PLUS_Dec_MAX_SIZE.<br>
     * @param samplerate [in]      Bitstream sampling rate.<br>
     * @param channels [in]        Bitstream number of channels.<br>
     * @param plc_mode [in]        Packet loss concealment mode.<br>
     * @return                     LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec_init(LC3PLUS_Dec*, int, int, LC3PLUS_PlcMode)</code><br>
     * <i>native declaration : lc3.h:336</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_init(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
     */
    @Deprecated
    int lc3plus_dec_init(Pointer decoder, int samplerate, int channels, int plc_mode, int hrmode);

    /**
     * Initialize LC3 decoder.<br>
     * This function is used to fill a user-allocated decoder struct. This is typically<br>
     * called once for a samplerate / channel / plc_mode configuration.<br>
     * The samplerate and channel arguments must have the same values that were used for encoding.<br>
     * LC3 does not provide a signalling scheme, transporting these values is the responsibility<br>
     * of the application.<br>
     * @param decoder [out]         Pointer to decoder memory. It must have as size of least<br>
     * LC3PLUS_Dec_get_size() or at most LC3PLUS_Dec_MAX_SIZE.<br>
     * @param samplerate [in]      Bitstream sampling rate.<br>
     * @param channels [in]        Bitstream number of channels.<br>
     * @param plc_mode [in]        Packet loss concealment mode.<br>
     * @return                     LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec_init(LC3PLUS_Dec*, int, int, LC3PLUS_PlcMode)</code><br>
     * <i>native declaration : lc3.h:336</i>
     */
    int lc3plus_dec_init(PointerByReference decoder, int samplerate, int channels, int plc_mode, int hrmode);

    /**
     * Decode compressed LC3 frame to 16 bit PCM output.<br>
     * Each call decodes a fixed number of samples. Use LC3PLUS_Dec_get_output_samples() to obtain this<br>
     * number. When the input is corrupted and can not be decoded, LC3PLUS_DECODE_ERROR is returned and<br>
     * packet loss concealment is applied, so the output is still usable.<br>
     * If error protection is enabled and the errors can be corrected the frame is corrected and<br>
     * normally decoded. Use LC3PLUS_Dec_get_error_report() to check if errors were corrected.<br>
     * @param decoder [in]         Decoder initialized by LC3PLUS_Dec_init().<br>
     * @param input_bytes [in]     Input bytes. If error protection is enabled the input bytes can be<br>
     * altered when error correction is applied. This is why this buffer<br>
     * must be writable.<br>
     * @param num_bytes [in]       Number of valid bytes in input_bytes. To signal a lost frame and<br>
     * generate concealment output this value must be set to 0.<br>
     * @param output_samples [out]  Array of pointers to output channel buffers. Each channel buffer<br>
     * should provide enough space to hold at most LC3PLUS_MAX_SAMPLES. The<br>
     * left channel is stored in output_samples[0], the right channel in<br>
     * output_samples[1].<br>
     * @param      scratch         A pointer to an allocated work buffer of at least<br>
     * LC3PLUS_Dec_get_scratch_size() or at most LC3PLUS_Dec_MAX_SCRATCH_SIZE<br>
     * bytes. The scratch buffer does not have to persist, so it can be<br>
     * used for other purposes in between calls.<br>
     * @return                     Returns LC3PLUS_OK on success or appropriate error code. Note there is<br>
     * a special case for LC3PLUS_DECODE_ERROR where the output is still valid.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec16(LC3PLUS_Dec*, void*, int, int16_t**, void*, int)</code><br>
     * <i>native declaration : lc3.h:368</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec16(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int, com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int lc3plus_dec16(Pointer decoder, Pointer input_bytes, int num_bytes, PointerByReference output_samples, Pointer scratch, int bfi_ext);

    /**
     * Decode compressed LC3 frame to 16 bit PCM output.<br>
     * Each call decodes a fixed number of samples. Use LC3PLUS_Dec_get_output_samples() to obtain this<br>
     * number. When the input is corrupted and can not be decoded, LC3PLUS_DECODE_ERROR is returned and<br>
     * packet loss concealment is applied, so the output is still usable.<br>
     * If error protection is enabled and the errors can be corrected the frame is corrected and<br>
     * normally decoded. Use LC3PLUS_Dec_get_error_report() to check if errors were corrected.<br>
     * @param decoder [in]         Decoder initialized by LC3PLUS_Dec_init().<br>
     * @param input_bytes [in]     Input bytes. If error protection is enabled the input bytes can be<br>
     * altered when error correction is applied. This is why this buffer<br>
     * must be writable.<br>
     * @param num_bytes [in]       Number of valid bytes in input_bytes. To signal a lost frame and<br>
     * generate concealment output this value must be set to 0.<br>
     * @param output_samples [out]  Array of pointers to output channel buffers. Each channel buffer<br>
     * should provide enough space to hold at most LC3PLUS_MAX_SAMPLES. The<br>
     * left channel is stored in output_samples[0], the right channel in<br>
     * output_samples[1].<br>
     * @param      scratch         A pointer to an allocated work buffer of at least<br>
     * LC3PLUS_Dec_get_scratch_size() or at most LC3PLUS_Dec_MAX_SCRATCH_SIZE<br>
     * bytes. The scratch buffer does not have to persist, so it can be<br>
     * used for other purposes in between calls.<br>
     * @return                     Returns LC3PLUS_OK on success or appropriate error code. Note there is<br>
     * a special case for LC3PLUS_DECODE_ERROR where the output is still valid.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec16(LC3PLUS_Dec*, void*, int, int16_t**, void*, int)</code><br>
     * <i>native declaration : lc3.h:368</i>
     */
    int lc3plus_dec16(PointerByReference decoder, Pointer input_bytes, int num_bytes, PointerByReference output_samples, Pointer scratch, int bfi_ext);

    /**
     * Decode compressed LC3 frame to 24 bit PCM output.<br>
     * The output samples are 24-bit values, sign-extended to 32-bit.<br>
     * See LC3PLUS_Dec16() for parameter documentation.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec24(LC3PLUS_Dec*, void*, int, int32_t**, void*, int)</code><br>
     * <i>native declaration : lc3.h:376</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec24(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int, com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int lc3plus_dec24(Pointer decoder, Pointer input_bytes, int num_bytes, PointerByReference output_samples, Pointer scratch, int bfi_ext);

    /**
     * Decode compressed LC3 frame to 24 bit PCM output.<br>
     * The output samples are 24-bit values, sign-extended to 32-bit.<br>
     * See LC3PLUS_Dec16() for parameter documentation.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec24(LC3PLUS_Dec*, void*, int, int32_t**, void*, int)</code><br>
     * <i>native declaration : lc3.h:376</i>
     */
    int lc3plus_dec24(PointerByReference decoder, Pointer input_bytes, int num_bytes, PointerByReference output_samples, Pointer scratch, int bfi_ext);

    /**
     * Get the size of the LC3 decoder struct for a samplerate / channel / plc_mode configuration.<br>
     * If memory is not restricted LC3PLUS_Dec_MAX_SIZE can be used for all configurations.<br>
     * @param channels [in]    Number of channels.<br>
     * @param samplerate [in]  Sampling rate.<br>
     * @param plc_mode [in]    Packet loss concealment mode.<br>
     * @return                 Size in bytes or 0 on error.<br>
     * Original signature : <code>int lc3plus_dec_get_size(int, int, LC3PLUS_PlcMode)</code><br>
     * <i>native declaration : lc3.h:387</i>
     */
    int lc3plus_dec_get_size(int samplerate, int channels, int plc_mode);

    /**
     * Get the size of the scratch buffer required by LC3PLUS_Dec16() or LC3PLUS_Dec24() for the current<br>
     * decoder configuration. If memory is not restricted LC3PLUS_Dec_MAX_SCRATCH_SIZE can be used for<br>
     * all configurations.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Size in bytes or 0 on error.<br>
     * Original signature : <code>int lc3plus_dec_get_scratch_size(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:396</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_get_scratch_size(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_dec_get_scratch_size(Pointer decoder);

    /**
     * Get the size of the scratch buffer required by LC3PLUS_Dec16() or LC3PLUS_Dec24() for the current<br>
     * decoder configuration. If memory is not restricted LC3PLUS_Dec_MAX_SCRATCH_SIZE can be used for<br>
     * all configurations.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Size in bytes or 0 on error.<br>
     * Original signature : <code>int lc3plus_dec_get_scratch_size(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:396</i>
     */
    int lc3plus_dec_get_scratch_size(PointerByReference decoder);

    /**
     * Get the number of samples per channel produced by LC3PLUS_Dec16() or LC3PLUS_Dec24.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Number of samples or 0 on error.<br>
     * Original signature : <code>int lc3plus_dec_get_output_samples(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:404</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_get_output_samples(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_dec_get_output_samples(Pointer decoder);

    /**
     * Get the number of samples per channel produced by LC3PLUS_Dec16() or LC3PLUS_Dec24.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Number of samples or 0 on error.<br>
     * Original signature : <code>int lc3plus_dec_get_output_samples(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:404</i>
     */
    int lc3plus_dec_get_output_samples(PointerByReference decoder);

    /**
     * Get the decoder delay in number of samples.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Delay in samples or 0 on error.<br>
     * Original signature : <code>int lc3plus_dec_get_delay(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:411</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_get_delay(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_dec_get_delay(Pointer decoder);

    /**
     * Get the decoder delay in number of samples.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Delay in samples or 0 on error.<br>
     * Original signature : <code>int lc3plus_dec_get_delay(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:411</i>
     */
    int lc3plus_dec_get_delay(PointerByReference decoder);

    /**
     * Set the frame length for LC3 decoder in deci milliseconds.<br>
     * Not all lengths may be enabled, in that case LC3PLUS_FRAMEMS_ERROR is returned.<br>
     * This only works correcly if the encoder was configured with the same vale.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @param frame_ms [in]    Frame length in ms.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec_set_frame_dms(LC3PLUS_Dec*, int)</code><br>
     * <i>native declaration : lc3.h:421</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_set_frame_dms(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    int lc3plus_dec_set_frame_dms(Pointer decoder, int frame_ms);

    /**
     * Set the frame length for LC3 decoder in deci milliseconds.<br>
     * Not all lengths may be enabled, in that case LC3PLUS_FRAMEMS_ERROR is returned.<br>
     * This only works correcly if the encoder was configured with the same vale.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @param frame_ms [in]    Frame length in ms.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec_set_frame_dms(LC3PLUS_Dec*, int)</code><br>
     * <i>native declaration : lc3.h:421</i>
     */
    int lc3plus_dec_set_frame_dms(PointerByReference decoder, int frame_ms);

    /**
     * Enable or disable error protection. Default value is 0 (disabled). If error protection is<br>
     * enabled, the decoder expects that the frames were encoded with error protection mode<br>
     * LC3_EP_ZERO or higher.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @param ep_enabled [in]  1 (or any nonzero) for true, 0 for false.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec_set_ep_enabled(LC3PLUS_Dec*, int)</code><br>
     * <i>native declaration : lc3.h:431</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_set_ep_enabled(com.sun.jna.ptr.PointerByReference, int)} instead
     */
    @Deprecated
    int lc3plus_dec_set_ep_enabled(Pointer decoder, int ep_enabled);

    /**
     * Enable or disable error protection. Default value is 0 (disabled). If error protection is<br>
     * enabled, the decoder expects that the frames were encoded with error protection mode<br>
     * LC3_EP_ZERO or higher.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @param ep_enabled [in]  1 (or any nonzero) for true, 0 for false.<br>
     * @return                 LC3PLUS_OK on success or appropriate error code.<br>
     * Original signature : <code>LC3PLUS_Error lc3plus_dec_set_ep_enabled(LC3PLUS_Dec*, int)</code><br>
     * <i>native declaration : lc3.h:431</i>
     */
    int lc3plus_dec_set_ep_enabled(PointerByReference decoder, int ep_enabled);

    /**
     * Retrieves the error protection mode reqeust from channel decoder.<br>
     * The return value encodes both the error protection mode request (EPMR)<br>
     * and the confidence of the method by which it was retrieved.<br>
     * The requested error protection mode is (epmr % 4) + 1, where epmr is the<br>
     * function's return value. The confidence is specified as follows.<br>
     * Confidence | Range<br>
     * -----------|-------------<br>
     * high       | 0 <= epmr < 4<br>
     * medium     | 4 <= epmr < 8<br>
     * no         | 8 <= epmr < 12<br>
     * When receiving stereo content of separately channel encoded audio frames the<br>
     * return value is the minimum of two values retrieved from the individual channels.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Error protection mode reqeust.<br>
     * Original signature : <code>LC3PLUS_EpModeRequest lc3plus_dec_get_ep_mode_request(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:453</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_get_ep_mode_request(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_dec_get_ep_mode_request(Pointer decoder);

    /**
     * Retrieves the error protection mode reqeust from channel decoder.<br>
     * The return value encodes both the error protection mode request (EPMR)<br>
     * and the confidence of the method by which it was retrieved.<br>
     * The requested error protection mode is (epmr % 4) + 1, where epmr is the<br>
     * function's return value. The confidence is specified as follows.<br>
     * Confidence | Range<br>
     * -----------|-------------<br>
     * high       | 0 <= epmr < 4<br>
     * medium     | 4 <= epmr < 8<br>
     * no         | 8 <= epmr < 12<br>
     * When receiving stereo content of separately channel encoded audio frames the<br>
     * return value is the minimum of two values retrieved from the individual channels.<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Error protection mode reqeust.<br>
     * Original signature : <code>LC3PLUS_EpModeRequest lc3plus_dec_get_ep_mode_request(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:453</i>
     */
    int lc3plus_dec_get_ep_mode_request(PointerByReference decoder);

    /**
     * Get the number of corrected bit errors in the last decoded frame. This only works if<br>
     * error protection is active. If the number of errors is greater than the current error<br>
     * protection mode can correct, -1 is returned. If the last frame had no errors or the<br>
     * decoder handle is NULL, 0 is returned,<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Number of corrected bits or -1. See description for details.<br>
     * Original signature : <code>int lc3plus_dec_get_error_report(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:463</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_get_error_report(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_dec_get_error_report(Pointer decoder);

    /**
     * Get the number of corrected bit errors in the last decoded frame. This only works if<br>
     * error protection is active. If the number of errors is greater than the current error<br>
     * protection mode can correct, -1 is returned. If the last frame had no errors or the<br>
     * decoder handle is NULL, 0 is returned,<br>
     * @param decoder [in]     Decoder handle.<br>
     * @return                 Number of corrected bits or -1. See description for details.<br>
     * Original signature : <code>int lc3plus_dec_get_error_report(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:463</i>
     */
    int lc3plus_dec_get_error_report(PointerByReference decoder);

    /**
     * This function returns an set of flags indicating whether the last frame<br>
     * would have been channel decodable in epmode m, m ranging from 1 to 4. Note that<br>
     * this information is not available in case the last frame was not channel<br>
     * decodable in which case the return value is 0. If the last frame would have<br>
     * been decodable in epmode m,  m-1th of the return value will be 1.<br>
     * Otherwise, if the frame would not have been decodable or if this information<br>
     * cannot be retrieved, the m-1th bit of the return value will be 0.<br>
     * Original signature : <code>int lc3plus_dec_get_epok_flags(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:472</i><br>
     *
     * @deprecated use the safer method {@link #lc3plus_dec_get_epok_flags(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int lc3plus_dec_get_epok_flags(Pointer decoder);

    /**
     * This function returns an set of flags indicating whether the last frame<br>
     * would have been channel decodable in epmode m, m ranging from 1 to 4. Note that<br>
     * this information is not available in case the last frame was not channel<br>
     * decodable in which case the return value is 0. If the last frame would have<br>
     * been decodable in epmode m,  m-1th of the return value will be 1.<br>
     * Otherwise, if the frame would not have been decodable or if this information<br>
     * cannot be retrieved, the m-1th bit of the return value will be 0.<br>
     * Original signature : <code>int lc3plus_dec_get_epok_flags(const LC3PLUS_Dec*)</code><br>
     * <i>native declaration : lc3.h:472</i>
     */
    int lc3plus_dec_get_epok_flags(PointerByReference decoder);

    class LC3PLUS_Enc extends PointerType {

        public LC3PLUS_Enc(Pointer address) {
            super(address);
        }

        public LC3PLUS_Enc() {
            super();
        }
    }

    class LC3PLUS_Dec extends PointerType {

        public LC3PLUS_Dec(Pointer address) {
            super(address);
        }

        public LC3PLUS_Dec() {
            super();
        }
    }

    String[] ERROR_MESSAGES = {
            "OK",                                                     /* LC3PLUS_OK                  */
            "Function call failed!",                                  /* LC3PLUS_ERROR               */
            "Frame failed to decode and was concealed!",              /* LC3PLUS_DECODE_ERROR        */
            "Pointer argument is null!",                              /* LC3PLUS_NULL_ERROR          */
            "Invalid sampling rate!",                                 /* LC3PLUS_SAMPLERATE_ERROR    */
            "Invalid number of channels!",                            /* LC3PLUS_CHANNELS_ERROR      */
            "Invalid bitrate!",                                       /* LC3PLUS_BITRATE_ERROR       */
            "Invalid number of bytes!",                               /* LC3PLUS_NUMBYTES_ERROR      */
            "Invalid PLC method!",                                    /* LC3PLUS_PLCMODE_ERROR       */
            "Invalid EP mode!",                                       /* LC3_EPCLASS_ERROR           */
            "Invalid frame ms value!",                                /* LC3PLUS_FRAMEMS_ERROR       */
            "Invalid usage of hrmode, sampling rate and frame size",  /* LC3PLUS_HRMODE_ERROR        */
            "Unaligned pointer!",                                     /* LC3PLUS_ALIGN_ERROR         */
            "Invalid channel mode request!",                          /* LC3_CMR_ERROR               */
            "Invalid usage of hrmode, sampling rate and frame size!", /* LC3PLUS_HRMODE_ERROR       */
            "Bitrate has not been set!",                              /* LC3PLUS_BITRATE_UNSET_ERROR */
            "Function can't be called after bitrate was set!",        /* LC3PLUS_BITRATE_SET_ERROR   */
            "Invalid external bad frame index!",                      /* LC3PLUS_BFI_EXT_ERROR       */
            "Generic Warning",                                        /* LC3PLUS_WARNING             */
            "Invalid bandwidth frequency!"                            /* LC3PLUS_BW_WARNING          */
    };
}
